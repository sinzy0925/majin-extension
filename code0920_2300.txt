background.js　の
const SCRIPT_ID = "1YUAmadVwnkM44Uld694CgPgmmkEFiSNmjklnhosfW7P6G7D5uAgv0R5o";
を、popup.htmlで入力できるようにしたい。
DEFAULT_SETTINGSの一つとして追加するのはどうやろか？

---



以下のアプリを詳細に理解してください。



//manifest.json
{
  "manifest_version": 3,
  "name": "スライド自動生成",
  "version": "5.0",
  "description": "AIと連携してGoogleスライドを自動生成します。",
  "action": {
    "default_popup": "popup.html"
  },
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["https://www.youtube.com/*"],
      "js": ["jquery.min.js", "content.js"]
    }
  ],
  "permissions": [
    "identity",
    "tabs",
    "storage" 
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "oauth2": {
    "client_id": "77855084094-c3jal48g1hd0emb487ggobtakrpsk6a2.apps.googleusercontent.com",
    "scopes": [
      "https://www.googleapis.com/auth/script.projects",
      "https://www.googleapis.com/auth/script.deployments",
      "https://www.googleapis.com/auth/script.scriptapp",
    "https://www.googleapis.com/auth/presentations",
    "https://www.googleapis.com/auth/drive"         
    ]
  },
  "web_accessible_resources": [
    {
      "resources": [
        "0.gs",
        "1.gs",
        "3.gs",
        "system_prompt.txt"
      ],
      "matches": [ "<all_urls>" ]
    }
  ],
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'; connect-src https://generativelanguage.googleapis.com/ https://script.googleapis.com/ https://script.google.com/ https://script.googleusercontent.com/;"
  }
}

---

// background.js

// --- デフォルト設定 (初回起動時やリセット時に使用) ---
const DEFAULT_SETTINGS = {
  deploymentId: "AKfycbzRaZy6u-VwYU-_misbfeiorUw-2U83A6lLaG1ROqC_ZAZb0ZKSdvirLiaNWtbHpTKWGA",
  apiKey: "",
  aiModel: 'gemini-2.5-flash'
};

const SCRIPT_ID = "1YUAmadVwnkM44Uld694CgPgmmkEFiSNmjklnhosfW7P6G7D5uAgv0R5o";
let activePort = null;

// --- 接続リスナー ---
chrome.runtime.onConnect.addListener((port) => {
  console.assert(port.name === "generate-channel");
  activePort = port;

  port.onMessage.addListener((msg) => {
    if (msg.action === "generateSlidesWithAI") {
      generateSlidesWithAI(msg.prompt, msg.settings);
    } else if (msg.action === "regenerateWithDesign") { // ▼▼▼ 追加 ▼▼▼
      regenerateWithDesign(msg.settings);
    }
  });

  port.onDisconnect.addListener(() => {
    activePort = null;
  });
});

// --- メッセージリスナー (popup.jsからの同期的な要求に応える) ---
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'getDefaultApiSettings') {
    sendResponse({
      deploymentId: DEFAULT_SETTINGS.deploymentId,
      apiKey: DEFAULT_SETTINGS.apiKey,
      aiModel: DEFAULT_SETTINGS.aiModel
    });
  }
  return true;
});


// --- 進捗をポップアップに送信するヘルパー関数 ---
function sendProgress(response) {
  if (activePort) {
    activePort.postMessage(response);
  }
}

// --- 機能: デザイン設定で0.gsの内容を書き換える ---
function createFile0Source(baseSource, settings) {
    let source = baseSource;
    if (settings) {
        if (settings.footerText) { source = source.replace(/const str_FOOTER_TEXT = `.*`;/, `const str_FOOTER_TEXT = \`${settings.footerText}\`;`); }
        if (settings.headerLogo) { source = source.replace(/const str_LOGOS_header= '.*'/, `const str_LOGOS_header= '${settings.headerLogo}'`); }
        if (settings.closingLogo) { source = source.replace(/const str_LOGOS_closing= '.*'/, `const str_LOGOS_closing= '${settings.closingLogo}'`); }
        if (settings.primaryColor) { source = source.replace(/const str_primary_color= '.*';/, `const str_primary_color= '${settings.primaryColor}';`); }
        const formatUrl = (url) => url ? `"${url}"` : 'null';
        if (settings.titleBg !== undefined) { source = source.replace(/const str_title_background_image_url= .*?;/, `const str_title_background_image_url= ${formatUrl(settings.titleBg)};`); }
        if (settings.contentBg !== undefined) { source = source.replace(/const str_content_background_image_url= .*?;/, `const str_content_background_image_url= ${formatUrl(settings.contentBg)};`); }
        if (settings.closingBg !== undefined) { source = source.replace(/const str_closing_background_image_url= .*?;/, `const str_closing_background_image_url= ${formatUrl(settings.closingBg)};`); }
    }
    return source;
}

// --- メインのスライド生成関数 ---
async function generateSlidesWithAI(userPrompt, settings) {
  try {
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${settings.aiModel}:generateContent?key=${settings.apiKey}`;

    sendProgress({ status: 'progress', message: 'AIがスライド構成案を作成中...'});
    const slideDataString = await getSlideDataFromAI(userPrompt, API_URL);
    
    sendProgress({ status: 'progress', message: 'GASプロジェクトを準備中...'});
    const token = await getAuthToken();

    const baseFile0Source = await fetch(chrome.runtime.getURL('0.gs')).then(res => res.text());
    const file0Source = createFile0Source(baseFile0Source, settings);
    
    const file1Source = await fetch(chrome.runtime.getURL('1.gs')).then(res => res.text());
    const file3Source = await fetch(chrome.runtime.getURL('3.gs')).then(res => res.text());
    
    sendProgress({ status: 'progress', message: 'GASプロジェクトを更新中...'});
    const newSource = createProjectSource(file0Source, file1Source, slideDataString, file3Source);
    await updateGasProject(SCRIPT_ID, token, newSource);

    sendProgress({ status: 'progress', message: '新バージョンを作成中...'});
    const versionResponse = await createNewVersion(SCRIPT_ID, token);
    const newVersionNumber = versionResponse.versionNumber;

    sendProgress({ status: 'progress', message: `デプロイを更新中 (v${newVersionNumber})...` });
    await updateDeployment(SCRIPT_ID, settings.deploymentId, token, newVersionNumber);

    sendProgress({ status: 'progress', message: 'スライドを生成しています...'});
    const WEB_APP_URL = `https://script.google.com/macros/s/${settings.deploymentId}/exec`;
    const result = await executeWebApp(WEB_APP_URL);
    
    sendProgress({ status: 'success', message: '完了: ' + result.message });

  } catch (error) {
    console.error("【CRITICAL ERROR】:", error);
    sendProgress({ status: 'error', message: error.message || '不明なエラーです。' });
  }
}

// --- ▼▼▼ 新しい関数 ▼▼▼ ---
// --- デザインのみ反映して再生成する関数 ---
async function regenerateWithDesign(settings) {
    try {
        sendProgress({ status: 'progress', message: 'デザイン反映の準備を開始...'});
        const token = await getAuthToken();

        sendProgress({ status: 'progress', message: '現在のスライド構成(2.gs)を取得中...'});
        const currentProject = await getGasProjectContent(SCRIPT_ID, token);
        const slideDataString = currentProject.files.find(f => f.name === '2')?.source;

        if (!slideDataString) {
            throw new Error("既存のスライド構成(2.gs)が見つかりません。先に一度「全自動で生成」を実行してください。");
        }

        const baseFile0Source = await fetch(chrome.runtime.getURL('0.gs')).then(res => res.text());
        const file0Source = createFile0Source(baseFile0Source, settings);

        const file1Source = await fetch(chrome.runtime.getURL('1.gs')).then(res => res.text());
        const file3Source = await fetch(chrome.runtime.getURL('3.gs')).then(res => res.text());
        
        sendProgress({ status: 'progress', message: 'GASプロジェクトを更新中...'});
        const newSource = createProjectSource(file0Source, file1Source, slideDataString, file3Source);
        await updateGasProject(SCRIPT_ID, token, newSource);

        sendProgress({ status: 'progress', message: '新バージョンを作成中...'});
        const versionResponse = await createNewVersion(SCRIPT_ID, token);
        const newVersionNumber = versionResponse.versionNumber;

        sendProgress({ status: 'progress', message: `デプロイを更新中 (v${newVersionNumber})...` });
        await updateDeployment(SCRIPT_ID, settings.deploymentId, token, newVersionNumber);

        sendProgress({ status: 'progress', message: 'スライドを再生成しています...'});
        const WEB_APP_URL = `https://script.google.com/macros/s/${settings.deploymentId}/exec`;
        const result = await executeWebApp(WEB_APP_URL);
        
        sendProgress({ status: 'success', message: '完了: デザインが反映されました。' });

    } catch (error) {
        console.error("【CRITICAL ERROR in regenerate】:", error);
        sendProgress({ status: 'error', message: error.message || '不明なエラーです。' });
    }
}
// --- ▲▲▲ 新しい関数ここまで ▲▲▲ ---


// -----------------------------------------------------------------------------
// --- 補助関数群 (変更なしのものは省略) ---
// -----------------------------------------------------------------------------

async function getSlideDataFromAI(userPrompt, apiUrl) {
  const systemPrompt = await fetch(chrome.runtime.getURL('system_prompt.txt')).then(res => res.text());
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 120000);
  try {
    const response = await fetch(apiUrl, {
      method: "POST", headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: systemPrompt + "\n\n---\n\n" + userPrompt }] }],
        safetySettings: [
          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
        ]
      }),
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!response.ok) { const errorData = await response.json(); throw new Error(`AI APIエラー: ${errorData.error.message}`); }
    const data = await response.json();
    if (!data.candidates || data.candidates.length === 0) { throw new Error("AIからの応答がありませんでした。"); }
    let rawText = data.candidates[0].content.parts[0].text;
    rawText = rawText.replace(/^```javascript\s*/, '').replace(/```\s*$/, '');
    return rawText.trim();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') { throw new Error("AI APIからの応答がタイムアウトしました（120秒）。"); }
    throw error;
  }
}

function getAuthToken() {
  return new Promise((resolve, reject) => {
    chrome.identity.getAuthToken({ interactive: true }, (token) => {
      if (chrome.runtime.lastError) { reject(chrome.runtime.lastError); } else { resolve(token); }
    });
  });
}

function createProjectSource(file0,file1, file2, file3) {
  const manifestContent = `{
    "timeZone": "Asia/Tokyo", "dependencies": {}, "exceptionLogging": "STACKDRIVER",
    "runtimeVersion": "V8", "webapp": { "executeAs": "USER_DEPLOYING", "access": "ANYONE_ANONYMOUS" }
  }`;
  return {
    files: [
      { name: "appsscript", type: "JSON", source: manifestContent }, 
      { name: "0", type: "SERVER_JS", source: file0 },
      { name: "1", type: "SERVER_JS", source: file1 },
      { name: "2", type: "SERVER_JS", source: file2 }, 
      { name: "3", type: "SERVER_JS", source: file3 }
    ]
  };
}

async function updateGasProject(scriptId, token, source) {
  const url = `https://script.googleapis.com/v1/projects/${scriptId}/content`;
  const response = await fetch(url, {
    method: 'PUT', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
    body: JSON.stringify(source)
  });
  if (!response.ok) { const errorData = await response.json(); throw new Error(`GASプロジェクトの更新に失敗: ${errorData.error.message}`); }
  return await response.json();
}

async function getGasProjectContent(scriptId, token) {
  const url = `https://script.googleapis.com/v1/projects/${scriptId}/content?fields=files(name,source)`;
  const response = await fetch(url, { method: 'GET', headers: { 'Authorization': `Bearer ${token}` } });
  if (!response.ok) { const errorData = await response.json(); throw new Error(`GASプロジェクト内容の取得に失敗: ${errorData.error.message}`); }
  return await response.json();
}

async function createNewVersion(scriptId, token) {
  const url = `https://script.googleapis.com/v1/projects/${scriptId}/versions`;
  const response = await fetch(url, {
    method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({ description: `Auto-deployed by extension at ${new Date().toISOString()}` })
  });
  if (!response.ok) { const errorData = await response.json(); throw new Error(`GASの新しいバージョンの作成に失敗: ${errorData.error.message}`); }
  return await response.json();
}

async function updateDeployment(scriptId, deploymentId, token, versionNumber) {
  const url = `https://script.googleapis.com/v1/projects/${scriptId}/deployments/${deploymentId}`;
  const response = await fetch(url, {
    method: 'PUT', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      deploymentConfig: { scriptId: scriptId, versionNumber: versionNumber, description: `Updated by extension to v${versionNumber}` }
    })
  });
  if (!response.ok) { const errorData = await response.json(); throw new Error(`GASのデプロイ更新に失敗: ${errorData.error.message}`); }
  return await response.json();
}

async function executeWebApp(url) {
  const response = await fetch(url, { method: 'POST', cache: 'no-cache' });
  if (!response.ok) { const errorText = await response.text(); throw new Error(`ウェブアプリ実行エラー: ステータス ${response.status}`); }
  const text = await response.text();
  try {
    const jsonResponse = JSON.parse(text);
    if (jsonResponse.logs && Array.isArray(jsonResponse.logs)) {
      console.groupCollapsed("📋 Google Apps Scriptからのログ");
      jsonResponse.logs.forEach(log => { console.log(log); sendProgress({ status: 'progress', message: log }); });
      console.groupEnd();
    }
    if (jsonResponse.status === 'error') { throw new Error(`GAS側でエラーが発生: ${jsonResponse.message}`); }
    return jsonResponse;
  } catch (e) {
    throw new Error("ウェブアプリ応答の解析に失敗しました。");
  }
}

---

//popup.html

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { width: 600px; padding: 10px; font-family: sans-serif; box-sizing: border-box; }
    h3, h4 { text-align: center; margin-bottom: 10px; }
    h4 { font-weight: normal; color: #555; margin-top: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px;}
    
    textarea, .settings-item input {
      width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px;
    }
    textarea { height: 150px; resize: vertical; }

    button { padding: 12px; font-size: 16px; cursor: pointer; border: none; border-radius: 4px; }
    button:disabled { cursor: not-allowed; }
    
    #generate-button { width: 100%; background-color: #4285F4; color: white; margin-bottom: 15px; }
    #generate-button:disabled { background-color: #a0c3ff; }
    
    .settings-group { margin-top: 10px; }
    
    .settings-item { display: flex; align-items: center; margin-bottom: 12px; }
    .settings-item label { flex: 0 0 160px; font-size: 14px; color: #333; padding-right: 10px; }
    .settings-item input { flex: 1; margin-bottom: 0; }
    
    .regenerate-section { padding-top: 10px; border-top: 1px solid #ccc; }
    .settings { display: flex; align-items: center; margin-bottom: 10px; }
    .settings label { flex: 1; }
    
    #regenerate-button { width: 100%; background-color: #34A853; color: white; }
    #regenerate-button:disabled { background-color: #a7d7b4; }
    
    .action-buttons { display: flex; gap: 10px; margin-bottom: 5px; align-items: center; }
    .action-buttons button { width: 150px; font-size: 14px; padding: 8px; }
    #save-settings-button { background-color: #0F9D58; color: white; }
    #reset-settings-button { background-color: #6c757d; color: white; }
    #feedback-message { flex: 1; font-size: 14px; color: #0F9D58; padding-left: 10px; }

    .collapsible {
      cursor: pointer;
      user-select: none;
      font-weight: bold;
      text-align: left;
    }
    .collapsible-content {
      padding-top: 10px;
      display: none;
      overflow: hidden;
    }
    
    /* ▼▼▼ 変更箇所 ▼▼▼ */
    #status-message {
      margin-top: 15px;
      font-size: 14px;
      min-height: 20px;
      text-align: center;
      color: #333;
      padding: 8px; /* 内側の余白を追加 */
      border-radius: 4px; /* 角を丸くする */
      background-color: #e8f0fe; /* 薄い青系の背景色 */
    }
    /* ▲▲▲ 変更箇所 ▲▲▲ */

  </style>
</head>
<body>
  <h3>スライド原稿入力</h3>
  <textarea id="user-prompt" placeholder="ここにスライドにしたい内容を貼り付け..."></textarea>
  
  <div class="settings-group">
    <h4>デザイン設定</h4>
    <div class="settings-item">
      <label for="footer-text">フッターテキスト</label>
      <input type="text" id="footer-text" placeholder="読み込み中...">
    </div>
    <div class="settings-item">
      <label for="header-logo">ヘッダーロゴURL</label>
      <input type="text" id="header-logo" placeholder="読み込み中...">
    </div>
    <div class="settings-item">
      <label for="closing-logo">クロージングロゴURL</label>
      <input type="text" id="closing-logo" placeholder="読み込み中...">
    </div>
    <div class="settings-item">
      <label for="title-bg">タイトル背景画像URL</label>
      <input type="text" id="title-bg">
    </div>
    <div class="settings-item">
      <label for="content-bg">本文背景画像URL</label>
      <input type="text" id="content-bg">
    </div>
    <div class="settings-item">
      <label for="closing-bg">最終頁 背景画像URL</label>
      <input type="text" id="closing-bg">
    </div>
    <div class="settings">
      <label for="primary-color">テーマカラー:</label>
      <input type="color" id="primary-color" value="#4285F4">
    </div>

    <div class="settings-group">
      <h4 class="collapsible">▼ API・連携設定 (必須項目です)</h4>
      <div class="collapsible-content">
        <div class="settings-item">
          <label for="deployment-id">Deployment ID</label>
          <input type="text" id="deployment-id">
        </div>
        <div class="settings-item">
          <label for="api-key">API Key</label>
          <input type="password" id="api-key">
        </div>
        <div class="settings-item">
          <label for="ai-model">AI Model</label>
          <input type="text" id="ai-model">
        </div>
      </div>
    </div>

    <div class="action-buttons">
      <button id="save-settings-button">設定を保存</button>
      <button id="reset-settings-button">初期状態に戻す</button>
      <span id="feedback-message"></span>
    </div>
  </div>


  <button id="generate-button">全自動でスライドを生成</button>
  <p id="status-message"></p>

  <div class="regenerate-section">
    <h4>微調整して再生成</h4>
    <button id="regenerate-button">デザインを反映して再生成</button>
  </div>
  
  <script src="popup.js"></script>
</body>
</html>

---

// popup.js
// popup.js
document.addEventListener('DOMContentLoaded', () => {
  // --- DOM要素の取得 ---
  const userPrompt = document.getElementById('user-prompt');
  const statusMessage = document.getElementById('status-message');
  const generateBtn = document.getElementById('generate-button');
  const regenerateBtn = document.getElementById('regenerate-button');
  
  const designInputs = {
    footerText: document.getElementById('footer-text'),
    headerLogo: document.getElementById('header-logo'),
    closingLogo: document.getElementById('closing-logo'),
    titleBg: document.getElementById('title-bg'),
    contentBg: document.getElementById('content-bg'),
    closingBg: document.getElementById('closing-bg'),
    primaryColor: document.getElementById('primary-color'),
  };

  const apiInputs = {
    deploymentId: document.getElementById('deployment-id'),
    apiKey: document.getElementById('api-key'),
    aiModel: document.getElementById('ai-model'),
  };

  const saveBtn = document.getElementById('save-settings-button');
  const resetBtn = document.getElementById('reset-settings-button');
  const feedbackMessage = document.getElementById('feedback-message');
  
  const collapsible = document.querySelector('.collapsible');
  const collapsibleContent = document.querySelector('.collapsible-content');

  const SETTINGS_KEY = 'userAppSettings';
  let port = null;

  // --- 機能: 折りたたみメニューの制御 ---
  collapsible.addEventListener('click', () => {
    const isExpanded = collapsible.classList.toggle('active');
    collapsibleContent.style.display = isExpanded ? 'block' : 'none';
    collapsible.textContent = isExpanded ? '▲ API・連携設定 (上級者向け)' : '▼ API・連携設定 (上級者向け)';
  });

  // --- 機能: フィードバックメッセージを表示 ---
  function showFeedback(message, isError = false) {
    feedbackMessage.textContent = message;
    feedbackMessage.style.color = isError ? '#D93025' : '#0F9D58';
    setTimeout(() => { feedbackMessage.textContent = ''; }, 4000);
  }

  // --- 機能: デフォルト設定の取得 ---
  async function getDefaultSettings() {
    const designDefaults = await (async () => {
      try {
        const res = await fetch(chrome.runtime.getURL('0.gs'));
        const text = await res.text();
        return {
          footerText: (text.match(/const str_FOOTER_TEXT = `([^`]+)`/) || [])[1]?.replace('${new Date().getFullYear()}', new Date().getFullYear()) || '',
          headerLogo: (text.match(/const str_LOGOS_header= '([^']+)'/) || [])[1] || '',
          closingLogo: (text.match(/const str_LOGOS_closing= '([^']+)'/) || [])[1] || '',
          primaryColor: (text.match(/const str_primary_color= '([^']+)';/) || [])[1] || '#4285F4',
          titleBg: (text.match(/const str_title_background_image_url= (.*?);/) || [])[1]?.replace(/["']/g, '').replace('null', '') || '',
          contentBg: (text.match(/const str_content_background_image_url= (.*?);/) || [])[1]?.replace(/["']/g, '').replace('null', '') || '',
          closingBg: (text.match(/const str_closing_background_image_url= (.*?);/) || [])[1]?.replace(/["']/g, '').replace('null', '') || ''
        };
      } catch (e) { return {}; }
    })();
    const apiDefaults = await chrome.runtime.sendMessage({ action: "getDefaultApiSettings" });
    return { ...designDefaults, ...apiDefaults };
  }

  // --- 機能: 設定オブジェクトをフォームに反映 ---
  function applySettingsToForm(settings) {
    if (!settings) return;
    Object.keys(designInputs).forEach(key => { designInputs[key].value = settings[key] || ''; });
    Object.keys(apiInputs).forEach(key => { apiInputs[key].value = settings[key] || ''; });
  }
  
  // --- 機能: 現在のフォームの内容から設定オブジェクトを取得 ---
  function getSettingsFromForm() {
    const settings = {};
    Object.keys(designInputs).forEach(key => { settings[key] = designInputs[key].value.trim(); });
    Object.keys(apiInputs).forEach(key => { settings[key] = apiInputs[key].value.trim(); });
    return settings;
  }

  // --- メインの読み込み処理 ---
  async function loadSettings() {
    const saved = (await chrome.storage.local.get([SETTINGS_KEY]))[SETTINGS_KEY];
    if (saved && Object.keys(saved).length > 0) {
      applySettingsToForm(saved);
    } else {
      const defaults = await getDefaultSettings();
      applySettingsToForm(defaults);
    }
  }

  loadSettings();

  // --- イベントリスナー: 保存ボタン ---
  saveBtn.addEventListener('click', () => {
    const settingsToSave = getSettingsFromForm();
    chrome.storage.local.set({ [SETTINGS_KEY]: settingsToSave }, () => {
      showFeedback('✓ 設定を保存しました');
    });
  });

  // --- イベントリスナー: リセットボタン ---
  resetBtn.addEventListener('click', () => {
    chrome.storage.local.remove([SETTINGS_KEY], async () => {
      const defaults = await getDefaultSettings();
      applySettingsToForm(defaults);
      showFeedback('設定をリセットしました');
    });
  });

  // --- 機能: ボタンを無効化し、ポート接続を準備する共通関数 ---
  function startProcess(action, payload) {
    const allSettings = getSettingsFromForm();
    
    // 必須項目チェック
    if (!allSettings.deploymentId || !allSettings.apiKey || !allSettings.aiModel) {
      statusMessage.textContent = "API・連携設定の必須項目を入力してください。";
      if (!collapsible.classList.contains('active')) {
        collapsible.click();
      }
      return;
    }

    if (action === 'generateSlidesWithAI' && !payload.prompt.trim()) {
        statusMessage.textContent = "プロンプトを入力してください。";
        return;
    }

    generateBtn.disabled = true;
    regenerateBtn.disabled = true;
    statusMessage.textContent = "処理を開始します...";

    if (port) port.disconnect();
    port = chrome.runtime.connect({ name: "generate-channel" });

    port.onMessage.addListener((msg) => {
        statusMessage.textContent = msg.message;
        if (msg.status === 'success' || msg.status === 'error') {
            generateBtn.disabled = false;
            regenerateBtn.disabled = false;
            if (port) port.disconnect();
        }
    });

    port.onDisconnect.addListener(() => {
        if (!statusMessage.textContent.startsWith("完了") && !statusMessage.textContent.startsWith("エラー")) {
            statusMessage.textContent = "エラー: 接続が予期せず切れました。";
        }
        generateBtn.disabled = false;
        regenerateBtn.disabled = false;
        port = null;
    });
    
    port.postMessage({ action, ...payload });
  }


  // --- イベントリスナー: 生成ボタンクリック ---
  generateBtn.addEventListener('click', () => {
    startProcess('generateSlidesWithAI', {
        prompt: userPrompt.value,
        settings: getSettingsFromForm()
    });
  });

  // --- イベントリスナー: 再生成ボタンクリック ---
  regenerateBtn.addEventListener('click', () => {
    startProcess('regenerateWithDesign', {
        settings: getSettingsFromForm()
    });
  });
});